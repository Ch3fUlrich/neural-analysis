"""Visualization functions for synthetic neural data.

This module provides integrated plotting capabilities for synthetic datasets
generated by neural_analysis.synthetic_data. All plots use the PlotGrid system
for consistent styling and layout.

Features:
- Automatic color-coding by cell type
- Raster plots showing neural activity
- Place field visualizations
- Behavioral trajectory plots
- Ground truth embeddings (ring, torus)
- Learned embeddings (PCA, UMAP, etc.)
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

import numpy as np
import numpy.typing as npt
from scipy import signal

from neural_analysis.embeddings.dimensionality_reduction import compute_embedding
from neural_analysis.plotting.grid_config import PlotGrid, PlotSpec

if TYPE_CHECKING:
    import matplotlib.pyplot as plt

# Define consistent colors for each cell type
CELL_TYPE_COLORS = {
    "place": "#E74C3C",  # Red
    "grid": "#3498DB",  # Blue
    "head_direction": "#2ECC71",  # Green
    "random": "#95A5A6",  # Gray
}


# ==============================================================================
# Helper Functions for Spatial Binning (Reduce Code Duplication)
# ==============================================================================

def _compute_spatial_bins_1d(
    positions: npt.NDArray[np.float64],
    activity: npt.NDArray[np.float64],
    arena_size: float | tuple[float, ...],
    n_bins: int = 50,
    cell_idx: int | None = None,
) -> tuple[npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Compute 1D spatial binning of activity.
    
    Args:
        positions: Position array, shape (n_samples, 1).
        activity: Activity array, shape (n_samples, n_cells).
        arena_size: Arena size (float or tuple).
        n_bins: Number of spatial bins.
        cell_idx: If specified, only bin this cell. Otherwise average all cells.
        
    Returns:
        bin_centers: Center position of each bin.
        binned_rates: Average firing rate in each bin.
    """
    # Get arena length
    if isinstance(arena_size, tuple):
        x_max = arena_size[0]
    else:
        x_max = arena_size
    
    # Create position bins
    x_bins = np.linspace(0, x_max, n_bins + 1)
    binned_rates = np.zeros(n_bins)
    
    # Compute average activity per position bin
    for i in range(n_bins):
        mask = (positions[:, 0] >= x_bins[i]) & (positions[:, 0] < x_bins[i + 1])
        if mask.sum() > 0:
            if cell_idx is not None:
                binned_rates[i] = activity[mask, cell_idx].mean()
            else:
                binned_rates[i] = activity[mask, :].mean()
    
    # Get bin centers for plotting
    bin_centers = (x_bins[:-1] + x_bins[1:]) / 2
    
    return bin_centers, binned_rates


def _compute_spatial_bins_2d(
    positions: npt.NDArray[np.float64],
    activity: npt.NDArray[np.float64],
    arena_size: tuple[float, ...],
    n_bins: int = 30,
    cell_idx: int | None = None,
) -> tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Compute 2D spatial binning of activity.
    
    Args:
        positions: Position array, shape (n_samples, 2).
        activity: Activity array, shape (n_samples, n_cells).
        arena_size: Arena size (width, height).
        n_bins: Number of spatial bins per dimension.
        cell_idx: If specified, only bin this cell. Otherwise average all cells.
        
    Returns:
        x_bins: X bin edges.
        y_bins: Y bin edges.
        firing_map: 2D firing rate map, shape (n_bins, n_bins).
    """
    # Get arena dimensions
    if isinstance(arena_size, tuple):
        x_max, y_max = arena_size
    else:
        x_max = y_max = arena_size
    
    # Create spatial bins
    x_bins = np.linspace(0, x_max, n_bins + 1)
    y_bins = np.linspace(0, y_max, n_bins + 1)
    
    # Initialize firing map with NaN for unvisited bins
    firing_map = np.full((n_bins, n_bins), np.nan)
    
    # Compute average activity per spatial bin
    for i in range(n_bins):
        for j in range(n_bins):
            mask = (
                (positions[:, 0] >= x_bins[i])
                & (positions[:, 0] < x_bins[i + 1])
                & (positions[:, 1] >= y_bins[j])
                & (positions[:, 1] < y_bins[j + 1])
            )
            if mask.sum() > 0:
                if cell_idx is not None:
                    firing_map[j, i] = activity[mask, cell_idx].mean()
                else:
                    firing_map[j, i] = activity[mask, :].mean()
    
    return x_bins, y_bins, firing_map


def _compute_spatial_bins_3d(
    positions: npt.NDArray[np.float64],
    activity: npt.NDArray[np.float64],
    arena_size: tuple[float, ...],
    n_bins: int = 20,
    cell_idx: int | None = None,
) -> tuple[npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]:
    """Compute 3D spatial binning of activity.
    
    Args:
        positions: Position array (n_samples, 3)
        activity: Activity array (n_samples, n_cells)
        arena_size: Arena size tuple (x, y, z)
        n_bins: Number of spatial bins per dimension
        cell_idx: If None, average across all cells; otherwise specific cell
    
    Returns:
        x_bins: X bin edges
        y_bins: Y bin edges
        z_bins: Z bin edges
        firing_volume: 3D firing rate map (n_bins, n_bins, n_bins)
    """
    x_max, y_max, z_max = arena_size
    
    x_bins = np.linspace(0, x_max, n_bins + 1)
    y_bins = np.linspace(0, y_max, n_bins + 1)
    z_bins = np.linspace(0, z_max, n_bins + 1)
    
    firing_volume = np.full((n_bins, n_bins, n_bins), np.nan)
    
    # Compute average activity per spatial bin
    for i in range(n_bins):
        for j in range(n_bins):
            for k in range(n_bins):
                mask = (
                    (positions[:, 0] >= x_bins[i]) & (positions[:, 0] < x_bins[i + 1]) &
                    (positions[:, 1] >= y_bins[j]) & (positions[:, 1] < y_bins[j + 1]) &
                    (positions[:, 2] >= z_bins[k]) & (positions[:, 2] < z_bins[k + 1])
                )
                if mask.sum() > 0:
                    if cell_idx is not None:
                        firing_volume[i, j, k] = activity[mask, cell_idx].mean()
                    else:
                        firing_volume[i, j, k] = activity[mask, :].mean()
    
    return x_bins, y_bins, z_bins, firing_volume


def _compute_radial_power_spectrum(
    power_spectrum_2d: npt.NDArray[np.float64],
    n_bins: int,
) -> npt.NDArray[np.float64]:
    """Compute radial average of 2D power spectrum.
    
    Args:
        power_spectrum_2d: 2D power spectrum (already shifted)
        n_bins: Number of radial bins
    
    Returns:
        radial_profile: 1D radial power profile
    """
    center = np.array(power_spectrum_2d.shape) // 2
    y_coords, x_coords = np.ogrid[:power_spectrum_2d.shape[0], :power_spectrum_2d.shape[1]]
    r = np.sqrt((x_coords - center[1])**2 + (y_coords - center[0])**2)
    r = r.astype(int)
    
    # Compute radial profile
    radial_profile = np.zeros(n_bins)
    for i in range(n_bins):
        mask = (r == i)
        if mask.sum() > 0:
            radial_profile[i] = power_spectrum_2d[mask].mean()
    
    return radial_profile


# ==============================================================================
# Main Plotting Function
# ==============================================================================

def plot_synthetic_data(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    show_raster: bool = True,
    show_fields: bool = True,
    show_behavior: bool = True,
    show_ground_truth: bool = True,
    show_embeddings: bool = True,
    embedding_methods: list[str] = None,
    n_embedding_dims: int = 2,
    max_raster_cells: int = 100,
    figsize: tuple[float, float] | None = None,
    backend: str = "matplotlib",
) -> plt.Figure:
    """Plot comprehensive visualization of synthetic neural data.

    Creates a multi-panel figure showing:
    - Raster plot of neural activity (color-coded by cell type)
    - Place fields or tuning curves (if applicable)
    - Behavioral trajectory
    - Ground truth embedding (ring/torus if available)
    - Learned embeddings (PCA, UMAP, etc.)

    Args:
        activity: Neural activity matrix, shape (n_samples, n_cells).
        metadata: Dictionary with dataset metadata (positions, cell_type, etc.).
        show_raster: Show neural activity raster plot.
        show_fields: Show place fields or tuning curves.
        show_behavior: Show behavioral trajectory.
        show_ground_truth: Show ground truth embedding (if available).
        show_embeddings: Show learned embeddings.
        embedding_methods: List of embedding methods ('pca', 'umap', 'tsne', etc.).
        n_embedding_dims: Dimensionality of embeddings (2 or 3).
        max_raster_cells: Maximum number of cells to show in raster.
        figsize: Figure size as (width, height).
        backend: 'matplotlib' or 'plotly'.

    Returns:
        fig: Matplotlib figure or Plotly figure object.

    Examples:
        >>> from neural_analysis.synthetic_data import generate_place_cells
        >>> activity, meta = generate_place_cells(50, 1000, plot=True)
        # This automatically calls plot_synthetic_data internally

        >>> # Or plot manually
        >>> activity, meta = generate_place_cells(50, 1000, plot=False)
        >>> fig = plot_synthetic_data(activity, meta)
    """
    if embedding_methods is None:
        embedding_methods = ["pca", "umap"]
    plot_specs = []
    n_plots = 0

    # Determine cell types and colors
    cell_type = metadata.get("cell_type", "unknown")
    cell_types = metadata.get("cell_types")

    if cell_types is not None:
        # Mixed population
        colors = [CELL_TYPE_COLORS.get(ct, "#7F8C8D") for ct in cell_types]
    else:
        # Single cell type
        colors = [CELL_TYPE_COLORS.get(cell_type, "#7F8C8D")] * activity.shape[1]

    # 1. Raster plot
    if show_raster:
        raster_spec = _create_raster_plot(
            activity, colors, max_cells=max_raster_cells, subplot_position=n_plots
        )
        plot_specs.append(raster_spec)
        n_plots += 1

    # 2. Place fields or tuning curves
    if show_fields:
        field_specs = _create_field_plots(
            activity, metadata, colors, subplot_position=n_plots
        )
        if field_specs:
            plot_specs.extend(field_specs)
            # For 1D, multiple specs go on same subplot, so only increment once
            # Count unique subplot positions instead of number of specs
            unique_positions = set(spec.subplot_position for spec in field_specs)
            n_plots += len(unique_positions)
        
        # Add coverage heatmap for place cells (1D and 2D)
        if metadata.get("cell_type") == "place":
            n_dims = metadata.get("n_dims", 2)
            if n_dims == 1:
                # 1D coverage: histogram of activity by position
                coverage_spec = _create_coverage_histogram_1d(activity, metadata, subplot_position=n_plots)
            elif n_dims == 2:
                # 2D coverage: spatial heatmap
                coverage_spec = _create_coverage_heatmap(activity, metadata, subplot_position=n_plots)
            else:
                coverage_spec = None
            
            if coverage_spec:
                plot_specs.append(coverage_spec)
                n_plots += 1
        
        # Add coverage heatmap for grid cells (1D and 2D)
        elif metadata.get("cell_type") == "grid":
            n_dims = metadata.get("n_dims", 2)
            if n_dims == 1:
                # 1D coverage: histogram of activity by position
                coverage_spec = _create_coverage_histogram_1d(activity, metadata, subplot_position=n_plots)
            elif n_dims == 2:
                # 2D coverage: spatial heatmap
                coverage_spec = _create_coverage_heatmap(activity, metadata, subplot_position=n_plots)
            else:
                coverage_spec = None
            
            if coverage_spec:
                plot_specs.append(coverage_spec)
                n_plots += 1

    # 3. Behavioral trajectory
    if show_behavior and "positions" in metadata:
        behavior_specs = _create_behavior_plot(metadata["positions"], metadata, subplot_position=n_plots)
        if behavior_specs:
            if isinstance(behavior_specs, list):
                plot_specs.extend(behavior_specs)
                n_plots += len(behavior_specs)
            else:
                plot_specs.append(behavior_specs)
                n_plots += 1

    # 4. Ground truth embedding
    if show_ground_truth and "ground_truth_embedding" in metadata:
        gt_spec = _create_ground_truth_plot(metadata, subplot_position=n_plots)
        if gt_spec:
            plot_specs.append(gt_spec)
            n_plots += 1

    # 5. Learned embeddings
    if show_embeddings:
        emb_specs = _create_embedding_plots(
            activity,
            metadata,
            embedding_methods,
            n_embedding_dims,
            subplot_position=n_plots,
        )
        plot_specs.extend(emb_specs)
        n_plots += len(emb_specs)

    # Create grid layout
    if n_plots == 0:
        raise ValueError("No plots to show. Enable at least one plot type.")

    # Compute optimal grid layout (minimize empty subplots)
    import math
    if n_plots <= 2:
        nrows, ncols = 1, n_plots
    elif n_plots <= 4:
        nrows, ncols = 2, 2
    elif n_plots <= 6:
        nrows, ncols = 2, 3
    else:
        # For more plots, use a more efficient layout
        ncols = min(3, n_plots)
        nrows = math.ceil(n_plots / ncols)

    # Create plot grid
    from neural_analysis.plotting.grid_config import GridLayoutConfig, PlotConfig

    grid = PlotGrid(
        plot_specs=plot_specs,
        config=PlotConfig(figsize=figsize or (ncols * 5, nrows * 4)),
        layout=GridLayoutConfig(
            rows=nrows, 
            cols=ncols,
            vertical_spacing=0.35,    # Increase vertical spacing to prevent overlap
            horizontal_spacing=0.25   # Horizontal spacing
        ),
        backend=backend,
    )

    result = grid.plot()
    # For matplotlib, grid.plot() returns (fig, axes); for plotly, just fig
    if backend == "matplotlib":
        fig, _ = result  # Unpack tuple
    else:
        fig = result

    # Add overall title with proper spacing
    title = f"Synthetic Neural Data: {cell_type.title()} Cells"
    if cell_types is not None:
        unique_types = sorted(set(cell_types))
        title = f"Synthetic Neural Data: Mixed Population ({', '.join(unique_types)})"

    if backend == "matplotlib":
        # Adjust suptitle position to avoid overlap
        fig.suptitle(title, fontsize=14, y=0.995)
        # Adjust subplot spacing to prevent overlap
        fig.tight_layout(rect=[0, 0, 1, 0.98])
    else:
        fig.update_layout(title_text=title)

    return fig


def _create_raster_plot(
    activity: npt.NDArray[np.float64],
    colors: list[str],
    max_cells: int,
    subplot_position: int,
) -> PlotSpec:
    """Create raster plot specification as heatmap with proper cell ID ticks."""
    n_samples, n_cells = activity.shape

    # Subsample cells if too many
    if n_cells > max_cells:
        step = n_cells // max_cells
        cell_indices = np.arange(0, n_cells, step)[:max_cells]
        activity_sub = activity[:, cell_indices]
    else:
        cell_indices = np.arange(n_cells)
        activity_sub = activity

    # Transpose to (n_cells, n_samples) for imshow-style display
    raster_data = activity_sub.T

    # Create integer yticks for cell IDs (matching periodicity heatmap)
    # Use evenly spaced ticks, showing actual cell indices
    n_ticks = min(10, len(cell_indices))  # Max 10 ticks to avoid crowding
    tick_step = max(1, len(cell_indices) // n_ticks)
    tick_positions = np.arange(0, len(cell_indices), tick_step)
    tick_labels = cell_indices[tick_positions].astype(int)

    # Create integer xticks for time axis
    n_time_ticks = min(6, n_samples // 50)  # Reasonable number of ticks
    if n_time_ticks > 0:
        time_tick_step = n_samples // n_time_ticks
        time_ticks = np.arange(0, n_samples + 1, time_tick_step)
        time_labels = time_ticks.astype(int)
    else:
        time_ticks = None
        time_labels = None

    # Create integer yticks for cell IDs
    n_cell_ticks = min(10, n_cells)  # Max 10 ticks to avoid crowding
    if n_cell_ticks > 0:
        cell_tick_step = max(1, n_cells // n_cell_ticks)
        cell_ticks = np.arange(0, n_cells + 1, cell_tick_step)
        cell_labels = cell_ticks.astype(int)
    else:
        cell_ticks = None
        cell_labels = None

    # Create as heatmap with proper extent to align cell IDs
    spec = PlotSpec(
        data=raster_data,
        plot_type="heatmap",
        subplot_position=subplot_position,
        title="Neural Activity Raster",
        cmap="hot",
        colorbar=True,
        colorbar_label="Firing Rate (Hz)",
        kwargs={
            "x_label": "Time (samples)",
            "y_label": "Cell ID",
            "interpolation": "nearest",
            "aspect": "auto",
            "extent": [0, n_samples, 0, n_cells],
            "origin": "lower",
            "set_xticks": time_ticks,
            "set_xticklabels": time_labels,
            "set_yticks": cell_ticks,
            "set_yticklabels": cell_labels,
        },
    )

    return spec


def _create_field_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> list[PlotSpec]:
    """Create place field or tuning curve plots."""
    specs = []
    cell_type = metadata.get("cell_type", "")
    n_dims = metadata.get("n_dims", 2)

    if cell_type == "place" and n_dims <= 2:
        # Place fields (1D and 2D)
        specs.extend(
            _create_place_field_plots(activity, metadata, colors, subplot_position)
        )
    elif cell_type == "grid":
        # Grid cell periodicity analysis (1D, 2D, and 3D via FFT)
        specs.extend(
            _create_grid_field_plots(activity, metadata, colors, subplot_position)
        )
    elif cell_type == "head_direction":
        # Head direction tuning curves
        spec = _create_hd_tuning_plot(activity, metadata, colors, subplot_position)
        if spec is not None:
            specs.append(spec)

    return specs


def _create_place_field_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> list[PlotSpec]:
    """Create place field visualization."""
    specs = []
    positions = metadata.get("positions")
    field_centers = metadata.get("field_centers")
    n_dims = metadata.get("n_dims", 2)

    if positions is None or field_centers is None:
        return specs

    if n_dims == 1:
        # 1D place fields: show firing rate vs position for multiple cells in ONE plot
        x_bins = np.linspace(positions.min(), positions.max(), 50)
        x_centers = (x_bins[:-1] + x_bins[1:]) / 2

        # Create a single plot with multiple lines (one per cell)
        # We'll create separate PlotSpecs for each line but with same subplot_position
        # so they all go on the same subplot
        for i in range(min(5, activity.shape[1])):  # Show first 5 cells
            rates = np.zeros(len(x_bins) - 1)
            for j in range(len(x_bins) - 1):
                mask = (positions[:, 0] >= x_bins[j]) & (
                    positions[:, 0] < x_bins[j + 1]
                )
                if mask.sum() > 0:
                    rates[j] = activity[mask, i].mean()

            spec = PlotSpec(
                data={"x": x_centers, "y": rates},
                plot_type="line",
                subplot_position=subplot_position,  # ALL lines use same position
                title="Place Fields (1D)" if i == 0 else None,  # Only first has title
                color=colors[i % len(colors)],
                label=f"Cell {i}",
                alpha=0.7,
                line_width=1.5,
                kwargs={"x_label": "Position (m)", "y_label": "Firing Rate (Hz)"} if i == 0 else {},
            )
            specs.append(spec)
        
        # Since all 5 cells go on the same subplot, we return all specs
        # but the calling code should only increment n_plots by 1, not 5
        # To fix this, we should return as single subplot worth of specs

    elif n_dims == 2:
        # 2D place fields: show anisotropic oval patches representing actual field shapes
        field_radii = metadata.get("field_radii")  # Shape: (n_cells, 2) with x,y radii
        field_angles = metadata.get("field_angles")  # Shape: (n_cells,) rotation angles
        
        # Create ellipse plot showing actual place field shapes
        spec = PlotSpec(
            data=field_centers,
            plot_type="ellipse",
            subplot_position=subplot_position,
            title="Place Fields (2D)",
            ellipse_widths=field_radii[:, 0] * 2 if field_radii is not None else np.ones(len(field_centers)) * 0.6,  # 1 std dev on each side = 2 * radius
            ellipse_heights=field_radii[:, 1] * 2 if field_radii is not None else np.ones(len(field_centers)) * 0.6,
            ellipse_angles=np.degrees(field_angles) if field_angles is not None else np.zeros(len(field_centers)),
            color="#E74C3C",  # Red for place fields
            alpha=0.25,
            kwargs={
                "x_label": "X Position (m)",
                "y_label": "Y Position (m)",
            },
        )
        specs.append(spec)
        
        # Add field centers as points
        spec_centers = PlotSpec(
            data=field_centers,
            plot_type="scatter",
            subplot_position=subplot_position,
            marker="x",
            marker_size=40,
            alpha=0.9,
            color="#C0392B",  # Darker red for centers
        )
        specs.append(spec_centers)

    return specs


def _create_coverage_heatmap(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | None:
    """Create spatial coverage heatmap for place/grid cells (unified function)."""
    positions = metadata.get("positions")
    arena_size = metadata.get("arena_size", (1.0, 1.0))
    cell_type = metadata.get("cell_type", "place")
    
    if positions is None or positions.shape[1] != 2:
        return None
    
    # Use helper function for spatial binning
    x_bins, y_bins, coverage_map = _compute_spatial_bins_2d(
        positions, activity, arena_size, n_bins=30, cell_idx=None
    )
    
    # Get arena dimensions for extent
    if isinstance(arena_size, tuple):
        x_max, y_max = arena_size
    else:
        x_max = y_max = arena_size
    
    # Choose colormap based on cell type
    cmap = "hot" if cell_type == "place" else "viridis"
    title = f"{cell_type.title()} Field Coverage"
    
    # Create heatmap spec with proper extent for correct axis labels
    spec = PlotSpec(
        data=coverage_map,
        plot_type="heatmap",
        subplot_position=subplot_position,
        title=title,
        cmap=cmap,
        colorbar=True,
        colorbar_label="Avg. Firing Rate (Hz)",
        kwargs={
            "x_label": "X Position (m)",
            "y_label": "Y Position (m)",
            "aspect": "auto",
            "extent": [0, x_max, 0, y_max],
            "origin": "lower",
        },
    )
    
    return spec


def _create_coverage_histogram_1d(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | None:
    """Create 1D coverage histogram for place/grid cells (unified function)."""
    positions = metadata.get("positions")
    arena_size = metadata.get("arena_size", 1.0)
    cell_type = metadata.get("cell_type", "place")
    
    if positions is None or positions.ndim != 2 or positions.shape[1] != 1:
        return None
    
    # Use helper function for spatial binning
    x_centers, coverage = _compute_spatial_bins_1d(
        positions, activity, arena_size, n_bins=50, cell_idx=None
    )
    
    # Choose color based on cell type
    color = CELL_TYPE_COLORS.get(cell_type, "#E74C3C")
    title = f"{cell_type.title()} Field Coverage (1D)"
    
    # Create line plot spec
    spec = PlotSpec(
        data={"x": x_centers, "y": coverage},
        plot_type="line",
        subplot_position=subplot_position,
        title=title,
        color=color,
        line_width=2,
        kwargs={
            "x_label": "Position (m)",
            "y_label": "Avg. Firing Rate (Hz)",
        },
    )
    
    return spec


def _create_hd_tuning_plot(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> PlotSpec:
    """Create head direction tuning curve plot."""
    preferred_angles = metadata.get("preferred_angles")
    head_directions = metadata.get("head_directions")

    if preferred_angles is None or head_directions is None:
        return None

    # Create tuning curves for first few cells
    angle_bins = np.linspace(-np.pi, np.pi, 36)

    # Average activity per angle bin for first cell
    rates = np.zeros(len(angle_bins) - 1)
    for i in range(len(angle_bins) - 1):
        mask = (head_directions >= angle_bins[i]) & (
            head_directions < angle_bins[i + 1]
        )
        if mask.sum() > 0:
            rates[i] = activity[mask, 0].mean()

    angles = np.degrees((angle_bins[:-1] + angle_bins[1:]) / 2)

    spec = PlotSpec(
        data={"x": angles, "y": rates},
        plot_type="line",
        subplot_position=subplot_position,
        title="Head Direction Tuning",
        color=colors[0],
    )

    return spec


def _create_grid_field_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> list[PlotSpec]:
    """Create grid cell periodicity analysis using FFT.
    
    Shows the periodic nature of grid cells by computing spectral analysis
    of firing rates in spatial domain. Displays a heatmap showing dominant
    frequencies for all cells with proper cell ID alignment.
    """
    specs = []
    positions = metadata.get("positions")
    n_dims = metadata.get("n_dims", 2)
    arena_size = metadata.get("arena_size", (2.0, 2.0))

    if positions is None:
        return specs

    n_cells = activity.shape[1]
    n_bins_fft = 100 if n_dims == 1 else 50  # More bins for 1D
    
    if n_dims == 1:
        # 1D periodicity: FFT of firing rates along the track
        periodicity_matrix = np.zeros((n_cells, n_bins_fft // 2))
        
        for cell_idx in range(n_cells):
            # Use helper to bin activity
            _, firing_rates = _compute_spatial_bins_1d(
                positions, activity, arena_size, n_bins=n_bins_fft, cell_idx=cell_idx
            )
            
            # Apply FFT
            fft_result = np.fft.fft(firing_rates)
            power_spectrum = np.abs(fft_result[:n_bins_fft // 2])
            
            periodicity_matrix[cell_idx, :] = power_spectrum
        
        # Create frequency axis (cycles per meter)
        track_length = arena_size if not isinstance(arena_size, tuple) else arena_size[0]
        freqs = np.fft.fftfreq(n_bins_fft, d=track_length / n_bins_fft)[:n_bins_fft // 2]
        
        # Create integer xticks for frequency axis
        n_freq_ticks = min(8, len(freqs) // 10)
        if n_freq_ticks > 0:
            freq_tick_step = len(freqs) // n_freq_ticks
            freq_tick_positions = np.arange(0, len(freqs), freq_tick_step)
            freq_tick_values = freqs[freq_tick_positions]
            # Map to extent coordinates
            freq_tick_coords = freqs[0] + (freqs[-1] - freqs[0]) * (freq_tick_positions / len(freqs))
            freq_tick_labels = [f"{int(f)}" for f in freq_tick_values]
        else:
            freq_tick_coords = None
            freq_tick_labels = None
        
        # Create integer yticks for cell IDs
        n_cell_ticks = min(10, n_cells)
        if n_cell_ticks > 0:
            cell_tick_step = max(1, n_cells // n_cell_ticks)
            cell_ticks = np.arange(0, n_cells + 1, cell_tick_step)
            cell_labels = cell_ticks.astype(int)
        else:
            cell_ticks = None
            cell_labels = None
        
        spec = PlotSpec(
            data=periodicity_matrix,
            plot_type="heatmap",
            subplot_position=subplot_position,
            title="Grid Cell Periodicity (1D FFT)",
            cmap="hot",
            colorbar=True,
            colorbar_label="Power",
            kwargs={
                "x_label": "Frequency (cycles/m)",
                "y_label": "Cell ID",
                "aspect": "auto",
                "extent": [freqs[0], freqs[-1], 0, n_cells],
                "origin": "lower",
                "set_xticks": freq_tick_coords,
                "set_xticklabels": freq_tick_labels,
                "set_yticks": cell_ticks,
                "set_yticklabels": cell_labels,
            },
        )
        specs.append(spec)
    
    elif n_dims == 2:
        # 2D periodicity: 2D FFT with radial averaging
        periodicity_matrix = np.zeros((n_cells, n_bins_fft))
        
        for cell_idx in range(n_cells):
            # Use helper to get 2D firing map
            _, _, firing_map = _compute_spatial_bins_2d(
                positions, activity, arena_size, n_bins=n_bins_fft, cell_idx=cell_idx
            )
            
            # Replace NaN with 0 for FFT
            firing_map = np.nan_to_num(firing_map, 0)
            
            # Apply 2D FFT
            fft_2d = np.fft.fft2(firing_map)
            power_spectrum_2d = np.abs(np.fft.fftshift(fft_2d))
            
            # Use helper for radial averaging
            radial_profile = _compute_radial_power_spectrum(power_spectrum_2d, n_bins_fft)
            
            periodicity_matrix[cell_idx, :] = radial_profile
        
        # Create frequency axis
        spatial_extent = max(arena_size) if isinstance(arena_size, tuple) else arena_size
        freqs = np.fft.fftfreq(n_bins_fft * 2, d=spatial_extent / n_bins_fft)[:n_bins_fft]
        freqs = np.abs(freqs)
        
        # Create integer xticks for frequency axis
        n_freq_ticks = min(8, len(freqs) // 10)
        if n_freq_ticks > 0:
            freq_tick_step = len(freqs) // n_freq_ticks
            freq_tick_positions = np.arange(0, len(freqs), freq_tick_step)
            freq_tick_values = freqs[freq_tick_positions]
            # Map to extent coordinates
            freq_tick_coords = freqs[0] + (freqs[-1] - freqs[0]) * (freq_tick_positions / len(freqs))
            freq_tick_labels = [f"{int(f)}" for f in freq_tick_values]
        else:
            freq_tick_coords = None
            freq_tick_labels = None
        
        # Create integer yticks for cell IDs
        n_cell_ticks = min(10, n_cells)
        if n_cell_ticks > 0:
            cell_tick_step = max(1, n_cells // n_cell_ticks)
            cell_ticks = np.arange(0, n_cells + 1, cell_tick_step)
            cell_labels = cell_ticks.astype(int)
        else:
            cell_ticks = None
            cell_labels = None
        
        spec = PlotSpec(
            data=periodicity_matrix,
            plot_type="heatmap",
            subplot_position=subplot_position,
            title="Grid Cell Periodicity (2D FFT)",
            cmap="hot",
            colorbar=True,
            colorbar_label="Power",
            kwargs={
                "x_label": "Spatial Frequency (cycles/m)",
                "y_label": "Cell ID",
                "aspect": "auto",
                "extent": [freqs[0], freqs[-1], 0, n_cells],
                "origin": "lower",
                "set_xticks": freq_tick_coords,
                "set_xticklabels": freq_tick_labels,
                "set_yticks": cell_ticks,
                "set_yticklabels": cell_labels,
            },
        )
        specs.append(spec)
    
    elif n_dims == 3:
        # 3D periodicity: True 3D FFT with radial averaging in 3D k-space
        n_bins_3d = 30  # Smaller for 3D due to computational cost
        periodicity_matrix = np.zeros((n_cells, n_bins_3d))
        
        for cell_idx in range(n_cells):
            # Use helper to get 3D firing volume
            _, _, _, firing_volume = _compute_spatial_bins_3d(
                positions, activity, arena_size, n_bins=n_bins_3d, cell_idx=cell_idx
            )
            
            # Replace NaN with 0 for FFT
            firing_volume = np.nan_to_num(firing_volume, 0)
            
            # Apply 3D FFT
            fft_3d = np.fft.fftn(firing_volume)
            power_spectrum_3d = np.abs(np.fft.fftshift(fft_3d))
            
            # Compute 3D radial average (spherical shells in k-space)
            center = np.array(power_spectrum_3d.shape) // 2
            z_coords, y_coords, x_coords = np.ogrid[
                :power_spectrum_3d.shape[0],
                :power_spectrum_3d.shape[1],
                :power_spectrum_3d.shape[2]
            ]
            r = np.sqrt(
                (x_coords - center[2])**2 + 
                (y_coords - center[1])**2 + 
                (z_coords - center[0])**2
            )
            r = r.astype(int)
            
            # Compute radial profile
            radial_profile = np.zeros(n_bins_3d)
            for i in range(n_bins_3d):
                mask = (r == i)
                if mask.sum() > 0:
                    radial_profile[i] = power_spectrum_3d[mask].mean()
            
            periodicity_matrix[cell_idx, :] = radial_profile
        
        # Create frequency axis
        spatial_extent = max(arena_size) if isinstance(arena_size, tuple) else arena_size
        freqs = np.fft.fftfreq(n_bins_3d * 2, d=spatial_extent / n_bins_3d)[:n_bins_3d]
        freqs = np.abs(freqs)
        
        # Create integer xticks for frequency axis
        n_freq_ticks = min(6, len(freqs) // 5)
        if n_freq_ticks > 0:
            freq_tick_step = len(freqs) // n_freq_ticks
            freq_tick_positions = np.arange(0, len(freqs), freq_tick_step)
            freq_tick_values = freqs[freq_tick_positions]
            # Map to extent coordinates
            freq_tick_coords = freqs[0] + (freqs[-1] - freqs[0]) * (freq_tick_positions / len(freqs))
            freq_tick_labels = [f"{int(f)}" for f in freq_tick_values]
        else:
            freq_tick_coords = None
            freq_tick_labels = None
        
        # Create integer yticks for cell IDs
        n_cell_ticks = min(10, n_cells)
        if n_cell_ticks > 0:
            cell_tick_step = max(1, n_cells // n_cell_ticks)
            cell_ticks = np.arange(0, n_cells + 1, cell_tick_step)
            cell_labels = cell_ticks.astype(int)
        else:
            cell_ticks = None
            cell_labels = None
        
        spec = PlotSpec(
            data=periodicity_matrix,
            plot_type="heatmap",
            subplot_position=subplot_position,
            title="Grid Cell Periodicity (3D FFT)",
            cmap="hot",
            colorbar=True,
            colorbar_label="Power",
            kwargs={
                "x_label": "Spatial Frequency (cycles/m)",
                "y_label": "Cell ID",
                "aspect": "auto",
                "extent": [freqs[0], freqs[-1], 0, n_cells],
                "origin": "lower",
                "set_xticks": freq_tick_coords,
                "set_xticklabels": freq_tick_labels,
                "set_yticks": cell_ticks,
                "set_yticklabels": cell_labels,
            },
        )
        specs.append(spec)
    
    return specs


def _create_behavior_plot(
    positions: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | list[PlotSpec]:
    """Create behavior trajectory/position plot."""
    n_dims = positions.shape[1] if positions.ndim > 1 else 1

    if n_dims == 1:
        # For 1D position, create a line plot over time
        spec = PlotSpec(
            data={"x": np.arange(len(positions)), "y": positions.ravel()},
            plot_type="line",
            subplot_position=subplot_position,
            title="Position on Linear Track",
            color="#3498DB",
            line_width=1,
            kwargs={"x_label": "Time (samples)", "y_label": "Position (m)"},
        )
    elif n_dims == 2:
        # For 2D, create trajectory with time coloring
        spec = PlotSpec(
            data={"x": positions[:, 0], "y": positions[:, 1]},
            plot_type="trajectory",  # Use trajectory instead of scatter
            subplot_position=subplot_position,
            title="2D Trajectory",
            color_by="time",
            cmap="viridis",
            line_width=1.5,
            alpha=0.7,
            colorbar=True,
            colorbar_label="Time",
            kwargs={"x_label": "X Position (m)", "y_label": "Y Position (m)"},
        )
    elif n_dims == 3:
        # For 3D, create 3D trajectory with time coloring
        spec = PlotSpec(
            data={
                "x": positions[:, 0],
                "y": positions[:, 1],
                "z": positions[:, 2],
            },
            plot_type="trajectory3d",  # Use trajectory3d instead of scatter3d
            subplot_position=subplot_position,
            title="3D Trajectory",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=3,
            alpha=0.7,
            colorbar=True,
            colorbar_label="Time",
            kwargs={"x_label": "X Position (m)", "y_label": "Y Position (m)", "z_label": "Z Position (m)"},
        )
    else:
        return None

    return spec


def _create_ground_truth_plot(
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | None:
    """Create ground truth embedding plot (ring/torus)."""
    gt_embedding = metadata.get("ground_truth_embedding")
    metadata.get("positions")

    if gt_embedding is None:
        return None

    n_dims = gt_embedding.shape[1]

    if n_dims == 2:
        spec = PlotSpec(
            data={"x": gt_embedding[:, 0], "y": gt_embedding[:, 1]},
            plot_type="scatter",
            subplot_position=subplot_position,
            title="Ground Truth Embedding (Ring)",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=3,
            alpha=0.6,
        )
    elif n_dims == 3:
        spec = PlotSpec(
            data={
                "x": gt_embedding[:, 0],
                "y": gt_embedding[:, 1],
                "z": gt_embedding[:, 2],
            },
            plot_type="scatter3d",
            subplot_position=subplot_position,
            title="Ground Truth Embedding (Torus)",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=2,
            alpha=0.6,
        )
    else:
        return None

    return spec


def _create_embedding_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    methods: list[str],
    n_dims: int,
    subplot_position: int,
) -> list[PlotSpec]:
    """Create learned embedding plots.
    
    NOTE: n_dims here refers to embedding dimensionality (2D or 3D),
    NOT the spatial dimensionality of the environment.
    """
    specs = []
    metadata.get("positions")

    for i, method in enumerate(methods):
        try:
            # Compute embedding
            embedding = compute_embedding(
                activity,
                method=method,
                n_components=n_dims,
                random_state=42,
            )

            if n_dims == 2:
                spec = PlotSpec(
                    data={"x": embedding[:, 0], "y": embedding[:, 1]},
                    plot_type="scatter",
                    subplot_position=subplot_position + i,
                    title=f"{method.upper()} Embedding",
                    color_by="time",
                    cmap="viridis",
                    marker="o",
                    marker_size=3,
                    alpha=0.6,
                )
            elif n_dims == 3:
                spec = PlotSpec(
                    data={
                        "x": embedding[:, 0],
                        "y": embedding[:, 1],
                        "z": embedding[:, 2],
                    },
                    plot_type="scatter3d",
                    subplot_position=subplot_position + i,
                    title=f"{method.upper()} Embedding",
                    color_by="time",
                    cmap="viridis",
                    marker="o",
                    marker_size=2,
                    alpha=0.6,
                )
            else:
                continue

            specs.append(spec)
        except Exception as e:
            print(f"Warning: Could not compute {method} embedding: {e}")
            continue

    return specs
