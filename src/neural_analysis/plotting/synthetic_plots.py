"""Visualization functions for synthetic neural data.

This module provides integrated plotting capabilities for synthetic datasets
generated by neural_analysis.synthetic_data. All plots use the PlotGrid system
for consistent styling and layout.

Features:
- Automatic color-coding by cell type
- Raster plots showing neural activity
- Place field visualizations
- Behavioral trajectory plots
- Ground truth embeddings (ring, torus)
- Learned embeddings (PCA, UMAP, etc.)
"""

from __future__ import annotations

from typing import TYPE_CHECKING, Any

import numpy as np
import numpy.typing as npt

from neural_analysis.embeddings.dimensionality_reduction import compute_embedding
from neural_analysis.plotting.grid_config import PlotGrid, PlotSpec

if TYPE_CHECKING:
    import matplotlib.pyplot as plt

# Define consistent colors for each cell type
CELL_TYPE_COLORS = {
    "place": "#E74C3C",  # Red
    "grid": "#3498DB",  # Blue
    "head_direction": "#2ECC71",  # Green
    "random": "#95A5A6",  # Gray
}


def plot_synthetic_data(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    show_raster: bool = True,
    show_fields: bool = True,
    show_behavior: bool = True,
    show_ground_truth: bool = True,
    show_embeddings: bool = True,
    embedding_methods: list[str] = None,
    n_embedding_dims: int = 2,
    max_raster_cells: int = 100,
    figsize: tuple[float, float] | None = None,
    backend: str = "matplotlib",
) -> plt.Figure:
    """Plot comprehensive visualization of synthetic neural data.

    Creates a multi-panel figure showing:
    - Raster plot of neural activity (color-coded by cell type)
    - Place fields or tuning curves (if applicable)
    - Behavioral trajectory
    - Ground truth embedding (ring/torus if available)
    - Learned embeddings (PCA, UMAP, etc.)

    Args:
        activity: Neural activity matrix, shape (n_samples, n_cells).
        metadata: Dictionary with dataset metadata (positions, cell_type, etc.).
        show_raster: Show neural activity raster plot.
        show_fields: Show place fields or tuning curves.
        show_behavior: Show behavioral trajectory.
        show_ground_truth: Show ground truth embedding (if available).
        show_embeddings: Show learned embeddings.
        embedding_methods: List of embedding methods ('pca', 'umap', 'tsne', etc.).
        n_embedding_dims: Dimensionality of embeddings (2 or 3).
        max_raster_cells: Maximum number of cells to show in raster.
        figsize: Figure size as (width, height).
        backend: 'matplotlib' or 'plotly'.

    Returns:
        fig: Matplotlib figure or Plotly figure object.

    Examples:
        >>> from neural_analysis.synthetic_data import generate_place_cells
        >>> activity, meta = generate_place_cells(50, 1000, plot=True)
        # This automatically calls plot_synthetic_data internally

        >>> # Or plot manually
        >>> activity, meta = generate_place_cells(50, 1000, plot=False)
        >>> fig = plot_synthetic_data(activity, meta)
    """
    if embedding_methods is None:
        embedding_methods = ["pca", "umap"]
    plot_specs = []
    n_plots = 0

    # Determine cell types and colors
    cell_type = metadata.get("cell_type", "unknown")
    cell_types = metadata.get("cell_types")

    if cell_types is not None:
        # Mixed population
        colors = [CELL_TYPE_COLORS.get(ct, "#7F8C8D") for ct in cell_types]
    else:
        # Single cell type
        colors = [CELL_TYPE_COLORS.get(cell_type, "#7F8C8D")] * activity.shape[1]

    # 1. Raster plot
    if show_raster:
        raster_spec = _create_raster_plot(
            activity, colors, max_cells=max_raster_cells, subplot_position=n_plots
        )
        plot_specs.append(raster_spec)
        n_plots += 1

    # 2. Place fields or tuning curves
    if show_fields:
        field_specs = _create_field_plots(
            activity, metadata, colors, subplot_position=n_plots
        )
        if field_specs:
            plot_specs.extend(field_specs)
            n_plots += len(field_specs)

    # 3. Behavioral trajectory
    if show_behavior and "positions" in metadata:
        behavior_specs = _create_behavior_plot(metadata["positions"], metadata, subplot_position=n_plots)
        if behavior_specs:
            if isinstance(behavior_specs, list):
                plot_specs.extend(behavior_specs)
                n_plots += len(behavior_specs)
            else:
                plot_specs.append(behavior_specs)
                n_plots += 1

    # 4. Ground truth embedding
    if show_ground_truth and "ground_truth_embedding" in metadata:
        gt_spec = _create_ground_truth_plot(metadata, subplot_position=n_plots)
        if gt_spec:
            plot_specs.append(gt_spec)
            n_plots += 1

    # 5. Learned embeddings
    if show_embeddings:
        emb_specs = _create_embedding_plots(
            activity,
            metadata,
            embedding_methods,
            n_embedding_dims,
            subplot_position=n_plots,
        )
        plot_specs.extend(emb_specs)
        n_plots += len(emb_specs)

    # Create grid layout
    if n_plots == 0:
        raise ValueError("No plots to show. Enable at least one plot type.")

    # Compute optimal grid layout (minimize empty subplots)
    import math
    if n_plots <= 2:
        nrows, ncols = 1, n_plots
    elif n_plots <= 4:
        nrows, ncols = 2, 2
    elif n_plots <= 6:
        nrows, ncols = 2, 3
    else:
        # For more plots, use a more efficient layout
        ncols = min(3, n_plots)
        nrows = math.ceil(n_plots / ncols)

    # Create plot grid
    from neural_analysis.plotting.grid_config import GridLayoutConfig, PlotConfig

    grid = PlotGrid(
        plot_specs=plot_specs,
        config=PlotConfig(figsize=figsize or (ncols * 5, nrows * 4)),
        layout=GridLayoutConfig(
            rows=nrows, 
            cols=ncols,
            vertical_spacing=0.35,    # Increase vertical spacing to prevent overlap
            horizontal_spacing=0.25   # Horizontal spacing
        ),
        backend=backend,
    )

    result = grid.plot()
    # For matplotlib, grid.plot() returns (fig, axes); for plotly, just fig
    if backend == "matplotlib":
        fig, _ = result  # Unpack tuple
    else:
        fig = result

    # Add overall title with proper spacing
    title = f"Synthetic Neural Data: {cell_type.title()} Cells"
    if cell_types is not None:
        unique_types = sorted(set(cell_types))
        title = f"Synthetic Neural Data: Mixed Population ({', '.join(unique_types)})"

    if backend == "matplotlib":
        # Adjust suptitle position to avoid overlap
        fig.suptitle(title, fontsize=14, y=0.995)
        # Adjust subplot spacing to prevent overlap
        fig.tight_layout(rect=[0, 0, 1, 0.98])
    else:
        fig.update_layout(title_text=title)

    return fig


def _create_raster_plot(
    activity: npt.NDArray[np.float64],
    colors: list[str],
    max_cells: int,
    subplot_position: int,
) -> PlotSpec:
    """Create raster plot specification as heatmap (matching notebook style)."""
    n_samples, n_cells = activity.shape

    # Subsample cells if too many
    if n_cells > max_cells:
        step = n_cells // max_cells
        cell_indices = np.arange(0, n_cells, step)[:max_cells]
        activity_sub = activity[:, cell_indices]
    else:
        activity_sub = activity

    # Transpose to (n_cells, n_samples) for imshow-style display
    # This matches the notebook: ax.imshow(activity.T, ...)
    raster_data = activity_sub.T

    # Create as heatmap (like notebook's imshow)
    spec = PlotSpec(
        data=raster_data,
        plot_type="heatmap",
        subplot_position=subplot_position,
        title="Neural Activity Raster",
        cmap="hot",
        colorbar=True,
        colorbar_label="Firing Rate (Hz)",
        kwargs={
            "x_label": "Time (samples)",
            "y_label": "Cell ID",
            "interpolation": "nearest",
            "aspect": "auto",
        },
    )

    return spec


def _create_field_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> list[PlotSpec]:
    """Create place field or tuning curve plots."""
    specs = []
    cell_type = metadata.get("cell_type", "")
    n_dims = metadata.get("n_dims", 2)

    if cell_type == "place" and n_dims <= 2:
        # Place fields
        specs.extend(
            _create_place_field_plots(activity, metadata, colors, subplot_position)
        )
    elif cell_type == "head_direction":
        # Head direction tuning curves
        spec = _create_hd_tuning_plot(activity, metadata, colors, subplot_position)
        if spec is not None:
            specs.append(spec)
    elif cell_type == "grid" and n_dims == 2:
        # Grid cell firing map
        spec = _create_grid_field_plot(activity, metadata, colors, subplot_position)
        if spec is not None:
            specs.append(spec)

    return specs


def _create_place_field_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> list[PlotSpec]:
    """Create place field visualization."""
    specs = []
    positions = metadata.get("positions")
    field_centers = metadata.get("field_centers")
    n_dims = metadata.get("n_dims", 2)

    if positions is None or field_centers is None:
        return specs

    if n_dims == 1:
        # 1D place fields: show firing rate vs position
        x_bins = np.linspace(positions.min(), positions.max(), 50)

        # Average activity in spatial bins
        for i in range(min(5, activity.shape[1])):  # Show first 5 cells
            rates = np.zeros(len(x_bins) - 1)
            for j in range(len(x_bins) - 1):
                mask = (positions[:, 0] >= x_bins[j]) & (
                    positions[:, 0] < x_bins[j + 1]
                )
                if mask.sum() > 0:
                    rates[j] = activity[mask, i].mean()

            spec = PlotSpec(
                data={"x": (x_bins[:-1] + x_bins[1:]) / 2, "y": rates},
                plot_type="line",
                subplot_position=subplot_position,
                title="Place Fields (1D)",
                color=colors[i],
                label=f"Cell {i}",
                alpha=0.7,
            )
            specs.append(spec)

    elif n_dims == 2:
        # 2D place fields: show firing rate heatmap
        # Overlay field centers
        spec = PlotSpec(
            data=field_centers,  # Already a 2D numpy array
            plot_type="scatter",
            subplot_position=subplot_position,
            title="Place Field Centers (2D)",
            marker="o",
            marker_size=8,
            alpha=0.7,
            color=colors[0],
        )
        specs.append(spec)

    return specs


def _create_hd_tuning_plot(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> PlotSpec:
    """Create head direction tuning curve plot."""
    preferred_angles = metadata.get("preferred_angles")
    head_directions = metadata.get("head_directions")

    if preferred_angles is None or head_directions is None:
        return None

    # Create tuning curves for first few cells
    angle_bins = np.linspace(-np.pi, np.pi, 36)

    # Average activity per angle bin for first cell
    rates = np.zeros(len(angle_bins) - 1)
    for i in range(len(angle_bins) - 1):
        mask = (head_directions >= angle_bins[i]) & (
            head_directions < angle_bins[i + 1]
        )
        if mask.sum() > 0:
            rates[i] = activity[mask, 0].mean()

    angles = np.degrees((angle_bins[:-1] + angle_bins[1:]) / 2)

    spec = PlotSpec(
        data={"x": angles, "y": rates},
        plot_type="line",
        subplot_position=subplot_position,
        title="Head Direction Tuning",
        color=colors[0],
    )

    return spec


def _create_grid_field_plot(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    colors: list[str],
    subplot_position: int,
) -> PlotSpec:
    """Create grid cell firing field plot."""
    positions = metadata.get("positions")

    if positions is None or positions.shape[1] != 2:
        return None

    # Show averaged firing field for first grid cell
    x_bins = np.linspace(positions[:, 0].min(), positions[:, 0].max(), 30)
    y_bins = np.linspace(positions[:, 1].min(), positions[:, 1].max(), 30)

    firing_map = np.zeros((len(y_bins) - 1, len(x_bins) - 1))
    for i in range(len(x_bins) - 1):
        for j in range(len(y_bins) - 1):
            mask = (
                (positions[:, 0] >= x_bins[i])
                & (positions[:, 0] < x_bins[i + 1])
                & (positions[:, 1] >= y_bins[j])
                & (positions[:, 1] < y_bins[j + 1])
            )
            if mask.sum() > 0:
                firing_map[j, i] = activity[mask, 0].mean()

    spec = PlotSpec(
        data=firing_map,
        plot_type="heatmap",
        subplot_position=subplot_position,
        title="Grid Cell Firing Field",
        cmap="viridis",
        colorbar=True,
    )

    return spec


def _create_behavior_plot(
    positions: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | list[PlotSpec]:
    """Create behavior trajectory/position plot."""
    n_dims = positions.shape[1] if positions.ndim > 1 else 1

    if n_dims == 1:
        # For 1D position, create a line plot over time
        spec = PlotSpec(
            data={"x": np.arange(len(positions)), "y": positions.ravel()},
            plot_type="line",
            subplot_position=subplot_position,
            title="Position on Linear Track",
            color="#3498DB",
            line_width=1,
            kwargs={"x_label": "Time (samples)", "y_label": "Position (m)"},
        )
    elif n_dims == 2:
        # For 2D, create scatter with time coloring
        spec = PlotSpec(
            data={"x": positions[:, 0], "y": positions[:, 1]},
            plot_type="scatter",
            subplot_position=subplot_position,
            title="2D Trajectory",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=5,
            alpha=0.6,
            colorbar=True,
            colorbar_label="Time",
            kwargs={"x_label": "X Position (m)", "y_label": "Y Position (m)"},
        )
    elif n_dims == 3:
        # For 3D, create 3D scatter with time coloring
        spec = PlotSpec(
            data={
                "x": positions[:, 0],
                "y": positions[:, 1],
                "z": positions[:, 2],
            },
            plot_type="scatter3d",
            subplot_position=subplot_position,
            title="3D Trajectory",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=3,
            alpha=0.7,
            colorbar=True,
            colorbar_label="Time",
            kwargs={"x_label": "X Position (m)", "y_label": "Y Position (m)", "z_label": "Z Position (m)"},
        )
    else:
        return None

    return spec


def _create_ground_truth_plot(
    metadata: dict[str, Any],
    subplot_position: int,
) -> PlotSpec | None:
    """Create ground truth embedding plot (ring/torus)."""
    gt_embedding = metadata.get("ground_truth_embedding")
    metadata.get("positions")

    if gt_embedding is None:
        return None

    n_dims = gt_embedding.shape[1]

    if n_dims == 2:
        spec = PlotSpec(
            data={"x": gt_embedding[:, 0], "y": gt_embedding[:, 1]},
            plot_type="scatter",
            subplot_position=subplot_position,
            title="Ground Truth Embedding (Ring)",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=3,
            alpha=0.6,
        )
    elif n_dims == 3:
        spec = PlotSpec(
            data={
                "x": gt_embedding[:, 0],
                "y": gt_embedding[:, 1],
                "z": gt_embedding[:, 2],
            },
            plot_type="scatter3d",
            subplot_position=subplot_position,
            title="Ground Truth Embedding (Torus)",
            color_by="time",
            cmap="viridis",
            marker="o",
            marker_size=2,
            alpha=0.6,
        )
    else:
        return None

    return spec


def _create_embedding_plots(
    activity: npt.NDArray[np.float64],
    metadata: dict[str, Any],
    methods: list[str],
    n_dims: int,
    subplot_position: int,
) -> list[PlotSpec]:
    """Create learned embedding plots."""
    specs = []
    metadata.get("positions")

    for i, method in enumerate(methods):
        try:
            # Compute embedding
            embedding = compute_embedding(
                activity,
                method=method,
                n_components=n_dims,
                random_state=42,
            )

            if n_dims == 2:
                spec = PlotSpec(
                    data={"x": embedding[:, 0], "y": embedding[:, 1]},
                    plot_type="scatter",
                    subplot_position=subplot_position + i,
                    title=f"{method.upper()} Embedding",
                    color_by="time",
                    cmap="viridis",
                    marker="o",
                    marker_size=3,
                    alpha=0.6,
                )
            elif n_dims == 3:
                spec = PlotSpec(
                    data={
                        "x": embedding[:, 0],
                        "y": embedding[:, 1],
                        "z": embedding[:, 2],
                    },
                    plot_type="scatter3d",
                    subplot_position=subplot_position + i,
                    title=f"{method.upper()} Embedding",
                    color_by="time",
                    cmap="viridis",
                    marker="o",
                    marker_size=2,
                    alpha=0.6,
                )
            else:
                continue

            specs.append(spec)
        except Exception as e:
            print(f"Warning: Could not compute {method} embedding: {e}")
            continue

    return specs
